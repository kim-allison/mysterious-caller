##### Intents and Slot filling
- Siri and Alexa.
>> not chatbots—at best, they’re horrible at conversation—but rather wrappers
around services that could otherwise be exposed through more conventional user interfaces
- the bot only replies to user utterances, which are structured more like *commands*
than conversational turns
>> the user issues such a command -> the natural language understanding (NLU) component of the system carries out two primary tasks: *intent recognition*
and *slot filling*
>>the action that the system must carry out to achieve the user’s command = user’s intent
>> the details associated with that action (its arguments, if you will) = slot values
ex) the user command turn down the living
room light might be attributed the intent adjust light and the slot values light: “living room”, adjustment: turn down (here, the keys are the slot names and the
values are the slot values)

- task-oriented dialogue system -> intent recognition, - all systems will need to carry out slot filling
>> slot filling = the process of deriving key–value pairs, where the keys correspond to the kinds
of information that your system cares about, and the values correspond to either snippets of text
(produced by the user or the bot) or items from a structured set
ex) to save the user’s name <- extracted from one of their utterances
ex) to record whether the user is a Carleton student <- the value originating in the set {True, False}.

- slot filling for this project: regular expressions and island parsing
>> if you define regular expressions that match values for certain slots, you can run them on the user’s messages and save the matches in key–value pairs in which the key is a slot name and the value is the matched text
ex) regex to grab a phone number or other highly structured data
>> for less structured slot values that are more linguistic in nature, you’ll want to use an island parser <- starting from the one you created last
assignment, though you’ll of course need to create a special grammar in which some of the
nonterminal symbols correspond to slot names
>> parse an island of text into such
a nonterminal, you can save create a key–value pair where the key is the nonterminal name (i.e.,
the associated slot name) and the value is the text of the parsed island. This may require your island parser to work at the string level, rather than at the token level, and I’ll be happy to help
you make the necessary adjustments. My recursive-descent parser operates at the string level
for this reason—i.e., it can parse arbitrary substrings, not just token sequences. One final trick that
I’ll mention is allowing for regular expressions in your island parser’s grammar. This would allow
for you to ignore spans of text that are within an island (not necessary)
- a task-oriented dialogue system for the project, it will have to be tricked out with some conversational ability (see the requirements listed in the next component).
That being said, it’s certainly an option for you. If you go this route, start thinking right away about
how you might achieve intent recognition and slot filling, which are the critical tasks in taskoriented
systems. You’ll also want to start thinking about the actions that your system will be able
to take, e.g., looking something up on Wikipedia. I’ll be happy to brainstorm with you about
potential technical approaches.

##### NER vs. Slot filling
- both tasks use sequence-tagging as an approach, but the goals are different
>> slot filling is looking for specific pieces of information with respect to something, and the information can be named entities (eg. who is spouse of this person?) but can also be other things (eg. when was this person born?). Exactly what information depends on the application, but Wikipedia info boxes are a good example. Slot-filling is usually used for knowledge base population tasks.

#### 
- intent classification: predicts the intent of the query
- slot filling: extracts semantic concepts in the query (tag)
ex) “Find me an action movie by Steven Spielberg”
-> intent: “find_movie” 
-> slots: “genre” with value “action” and “directed_by” with value “Steven Spielberg”
>> slots are the variables you give your program to let your bot categorize and interpret users’ input
ex) “I want to order a pepperoni pizza,” your bot first has to understand that the user is asking for an order. Next, to narrow down what kind of suggestion it should give, it finds the slots in the sentence.
>> bot would identify the statement as a #place_order intent with an @pizza_type slot and a “pepperoni” value. From there, your bot can place the order for the correct pizza and then respond to the user with payment and order details.

